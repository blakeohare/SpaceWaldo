import Graphics2D;
import Math;

class Sprite {
	field x = 0.0;
	field y = 0.0;
	field vx = 0.0;
	field vy = 0.0;
	field isDead = false;
	field isNear = false;
	field radius = 10.0;
	field collisionVelocity = null;
	field scene;
	
	constructor(scene) {
		this.scene = scene;
	}
	
	function update() {
		this.collisionVelocity = null;
		
		this.vy += this.scene.currentGravity;
		
		// cap velocity at 8 pixels per frame (that's 2 seconds to traverse an entire screen width @ 60 FPS)
		v = (this.vx ** 2 + this.vy ** 2) ** .5;
		if (v > 8) {
			this.vx = 8.0 * this.vx / v;
			this.vy = 8.0 * this.vy / v;
			v = 8.0;
		}
		
		// Try moving 3 times, each time splitting half the distance.
		// This is super tacky, but hey, it's a game jam.
		// The collision velocity is applied after the first attempt.
		cv = this.doMovement(1);
		this.collisionVelocity = cv;
		
		if (cv != null && cv > 2) {
			cv = this.doMovement(.5);
			if (cv != null && cv > 2) {
				cv = this.doMovement(.25);
			}
			
		}
		
		if (cv != null) {
			this.vx = 0;
			this.vy = 0;
		}
		
	}
	
	function doMovement(velocityRatio) {
		
		newX = this.x + this.vx * velocityRatio;
		newY = this.y + this.vy * velocityRatio;
		
		isCollision = this.scene.landscape.doCollisionDetection(newX, newY, this.radius);
		if (isCollision) {
			return velocityRatio * (this.vx ** 2 + this.vy ** 2) ** .5;
		}
		
		this.x = newX;
		this.y = newY;
		
		return null;
	}
	
	function render(cameraX, cameraY) {
		throw new Exception("Override me");
	}
	
	function getAngleOffsetFromVerticallyAligned() {
		return Math.arctan(this.vx, this.vy);
	}
}

class LanderShip : Sprite {

	field img;
	constructor(scene) : base(scene) {
		this.radius = 15;
		this.img = ImageLibrary.get('lander.png');
	}
	
	function render(cameraX, cameraY) {
		x = Math.floor(this.x - cameraX);
		y = Math.floor(this.y - cameraY - this.radius);
		thetaOffset = this.getAngleOffsetFromVerticallyAligned() / 4.0;
		this.img.drawRotated(x, y, thetaOffset);
	}
}

class MoonLanderScene : AbstractScene {
	
	field currentGravity = .2;
	field sprites = [];
	field player;
	field landscape;
	
	constructor() : base() {
		this.landscape = new Landscape('basic');
		this.player = new LanderShip(this);
		this.player.y = -800;
		this.sprites = [this.player];
	}
	
	function update(input) {
		
		for (sprite : this.sprites) {
			dx = sprite.x - this.player.x;
			dy = sprite.y - this.player.y;
			distance = (dx ** 2 + dy ** 2) ** .5;
			if (distance < 1500) {
				sprite.update();
				sprite.isNear = true;
			} else {
				sprite.isNear = false;
			}
		}
		
		if (input.pressed && input.y > 490) { // MAGIC NUMBER
			leftRightRatio = (input.x - 306) / 320.0;
			if (leftRightRatio >= 0 && leftRightRatio <= 1) {
				ratio = leftRightRatio * 2.0 - 1;
				
				this.player.vx += -ratio * .4;
				
				lift = (1 - abs(ratio) * 2);
				if (lift > 0) {
					lift *= .33;
					this.player.vy -= lift;
				}
			}
		}
	}
	
	function render(rc) {
		cameraX = Math.floor(this.player.x - WIDTH / 2);
		cameraY = Math.floor(this.player.y - HEIGHT / 2);
		
		hud = ImageLibrary.get('lander_controls.png');
		
		Draw.fill(0, 0, 80);
		groundY = -cameraY;
		
		for (chunk = this.landscape.getChunkAt(cameraX); // leftmost chunk on the screen
			chunk.absoluteX - cameraX < WIDTH; // is it actually on the screen?
			chunk = this.landscape.getChunkAt(chunk.absoluteX + chunk.width + 1)) { // get the chunk at the right of this one
			
			color = chunk.color;
			Draw.rectangle(
				chunk.absoluteX - cameraX, chunk.topY - cameraY,
				chunk.width, chunk.height,
				color[0], color[1], color[2]);
		}
		
		for (sprite : this.sprites) {
			if (sprite.isNear) {
				sprite.render(cameraX, cameraY);
			}
		}
		
		hud.draw(0, HEIGHT - hud.height);
	}
}
