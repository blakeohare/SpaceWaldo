import Math;

class SpaceScene : AbstractScene {
	
	field cachedSectors = {}; // key is "x,y", value is a SpaceSector instance
	
	field player;
	field dxdy = null;
	field stardate;
	
	constructor(stardate, startingX, startingY) : base() {
		this.player = new SpaceSprite(this, SpaceObjectType.SHIP, 'player');
		
		// all planet movement is a parametric equation of this counter.
		// When a ship leaves a planet or moon, the ship is returned to the planet (or moon's parent planet's) location
		// at the stardate you landed at. Then the stardate is advanced by 1.5 seconds to move it out of the way and will
		// guarantee there isn't an instantaneous collision that sends you back to the planet/moon.
		this.stardate = stardate; 
		
		// named portion of the galaxy is a 9x9 grid of sectors which are 2000x2000 pixels each, so this is the center
		this.player.x = startingX + 0.0;
		this.player.y = startingY + 0.0;
	}
	
	function update(input) {
		this.stardate++;
		
		this.dxdy = null;
		
		if (input != null && input.pressed) {
			// normalize into a [-1 to 1] space in each dimension
			dx = (input.x - 452) / 80.0;
			dy = (input.y - 519) / 70.0;
			
			// create a little tolerance to go out of bounds.
			dx *= .9;
			dy *= .9;
			
			// is the touch event within the control?
			dist = (dx ** 2 + dy ** 2) ** .5;
			if (dist <= 1.0) {
				this.player.vx += dx / 2;
				this.player.vy += dy / 2;
				this.dxdy = (floor(dx * 1000) / 1000.0) + ', ' + (floor(dy * 1000) / 1000.0);
			}
		}
		
		this.player.update(this.stardate);
		
		cameraX = this.player.x - WIDTH / 2;
		cameraY = this.player.y - HEIGHT / 2;
		
		collidedWith = null;
		
		for (sector : this.getAllVisibleSectors(cameraX, cameraY)) {
			sector.update(this.stardate);
			
			for (sprite : sector.sprites) {
				if (sprite.type == SpaceObjectType.PLANET ||
					sprite.type == SpaceObjectType.MOON) {
					
					dx = sprite.x - this.player.x;
					dy = sprite.y - this.player.y;
					d = (dx ** 2 + dy ** 2) ** .5;
					if (d < 100 && // optimization
						d < sprite.radius + this.player.radius) {
						
						collidedWith = sprite;
					}
				}
			}
		}
		
		if (collidedWith != null) {
			this.switchScene(new TransitionScene(this, new MoonLanderScene(this.stardate, collidedWith, collidedWith.type, collidedWith.label)));
		}
	}
	
	function render(rc) {
		cameraX = this.player.x - WIDTH / 2;
		cameraY = this.player.y - HEIGHT / 2;
		
		this.drawStars(cameraX, cameraY);
		
		for (sector : this.getAllVisibleSectors(cameraX, cameraY)) {
			sector.render(rc, cameraX, cameraY);
		}
		
		this.player.render(rc, cameraX, cameraY);
		
		img = ImageLibrary.get('space_controls.png');
		img.draw(0, HEIGHT - img.height);
		
		x = floor(this.player.x * 1000) / 1000.0;
		y = floor(this.player.y * 1000) / 1000.0;
		vx = floor(this.player.vx * 1000) / 1000.0;
		vy = floor(this.player.vy * 1000) / 1000.0;
		
		/*
		TextEngine.render('Pos: ' + x + ', ' + y + '\nVel: ' + vx + ', ' + vy, 'white', FontSize.XS, 5, 5);
		if (this.dxdy != null) {
			TextEngine.render(this.dxdy, 'yellow', FontSize.XS, 5, 50);
		}
		//*/
	}
	
	function drawStars(cx, cy) {
		stars = ImageLibrary.get('stars.png');
		
		x = Math.floor(-this.player.x * .6) % 1000;
		y = Math.floor(-this.player.y * .6) % 1000;
		
		stars.draw(x, y);
		stars.draw(x - 1000, y);
		stars.draw(x, y - 1000);
		stars.draw(x - 1000, y - 1000);
		
	}
	function getAllVisibleSectors(cameraX, cameraY) {
		cx = floor(cameraX);
		rcx = cx + WIDTH;
		cy = floor(cameraY);
		rcy = cy + HEIGHT;
		sectorLeft = (cx - cx % 2000) / 2000;
		sectorRight = (rcx - rcx % 2000) / 2000;
		sectorTop = (cy - cy % 2000) / 2000;
		sectorBottom = (rcy - rcy % 2000) / 2000;
		
		sectors = [];
		debug = [];
		for (y = sectorTop; y <= sectorBottom; ++y) {
			for (x = sectorLeft; x <= sectorRight; ++x) {
				sectors.add(this.getSector(x, y));
				debug.add(x + ', ' + y);
			}
		}
		
		//TextEngine.render(debug.join('  '), 'red', FontSize.XS, 5, 80);
		
		return sectors;
	}
	
	function getSector(x, y) {
		key = x + ',' + y;
		sector = this.cachedSectors.get(key);
		if (sector == null) {
			sector = new SpaceSector(this, x, y);
			this.cachedSectors[key] = sector;
		}
		return sector;
	}
}
