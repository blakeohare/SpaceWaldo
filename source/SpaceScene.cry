import Math;

class SpaceScene : AbstractScene {
	
	field cachedSectors = {}; // key is "x,y", value is a SpaceSector instance
	
	field player;
	field dxdy = null;
	
	constructor(startingX, startingY) : base() {
		this.player = new SpaceSprite(this, SpaceObjectType.SHIP, 'player');
	}
	
	function update(input) {
		this.dxdy = null;
		
		if (input.pressed) {
			// normalize into a [-1 to 1] space in each dimension
			dx = (input.x - 452) / 80.0;
			dy = (input.y - 519) / 70.0;
			
			// create a little tolerance to go out of bounds.
			dx *= .9;
			dy *= .9;
			
			// is the touch event within the control?
			dist = (dx ** 2 + dy ** 2) ** .5;
			if (dist <= 1.0) {
				this.player.vx += dx / 2;
				this.player.vy += dy / 2;
				this.dxdy = (floor(dx * 1000) / 1000.0) + ', ' + (floor(dy * 1000) / 1000.0);
			}
		}
		
		this.player.update();
		
		cameraX = this.player.x - WIDTH / 2;
		cameraY = this.player.y - HEIGHT / 2;
		
		for (sector : this.getAllVisibleSectors(cameraX, cameraY)) {
			sector.update();
			
			for (sprite : sector.sprites) {
				dx = sprite.x - this.player.x;
				dy = sprite.y - this.player.y;
				d = (dx ** 2 + dy ** 2) ** .5;
				if (d < 100 && // optimization
					d < sprite.radius + this.player.radius) {
					
					print("Collision with " + (sprite.label ?? 'null'));
				}
			}
		}
	}
	
	function render(rc) {
		cameraX = this.player.x - WIDTH / 2;
		cameraY = this.player.y - HEIGHT / 2;
		
		for (sector : this.getAllVisibleSectors(cameraX, cameraY)) {
			sector.render(rc, cameraX, cameraY);
		}
		
		this.player.render(rc, cameraX, cameraY);
		
		img = ImageLibrary.get('space_controls.png');
		img.draw(0, HEIGHT - img.height);
		
		x = floor(this.player.x * 1000) / 1000.0;
		y = floor(this.player.y * 1000) / 1000.0;
		
		TextEngine.render('(' + x + ', ' + y + ')', 'white', FontSize.XS, 5, 5);
		if (this.dxdy != null) {
			TextEngine.render(this.dxdy, 'yellow', FontSize.XS, 5, 30);
		}
		
	}
	
	function getAllVisibleSectors(cameraX, cameraY) {
	
		sectorLeft = cameraX / 2000;
		sectorRight = (cameraX + WIDTH) / 2000;
		sectorTop = cameraY / 2000;
		sectorBottom = (cameraY + HEIGHT) / 2000;
		
		sectors = [];
		for (y = sectorTop; y <= sectorBottom; ++y) {
			for (x = sectorLeft; x <= sectorLeft; ++x) {
				sectors.add(this.getSector(x, y));
			}
		}
		return sectors;
	}
	
	function getSector(x, y) {
		key = x + ',' + y;
		sector = this.cachedSectors.get(key);
		if (sector == null) {
			sector = new SpaceSector(x, y);
			this.cachedSectors[key] = sector;
		}
		return sector;
	}
}
